"use strict";(self.webpackChunkfeature_probe_docs=self.webpackChunkfeature_probe_docs||[]).push([[8311],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>g});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var u=n.createContext({}),s=function(e){var t=n.useContext(u),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=s(e.components);return n.createElement(u.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,u=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),h=s(a),g=r,c=h["".concat(u,".").concat(g)]||h[g]||d[g]||l;return a?n.createElement(c,i(i({ref:t},p),{},{components:a})):n.createElement(c,i({ref:t},p))}));function g(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=h;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var s=2;s<l;s++)i[s]=a[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},1742:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>s});var n=a(7462),r=(a(7294),a(3905));const l={sidebar_position:5},i="Rule Evaluation",o={unversionedId:"reference/evaluation-rules",id:"reference/evaluation-rules",title:"Rule Evaluation",description:"Overview",source:"@site/docs/reference/evaluation-rules.md",sourceDirName:"reference",slug:"/reference/evaluation-rules",permalink:"/FeatureProbe/reference/evaluation-rules",draft:!1,editUrl:"https://github.com/FeatureProbe/FeatureProbe/blob/main/docs/docs/reference/evaluation-rules.md",tags:[],version:"current",lastUpdatedAt:1679370529,formattedLastUpdatedAt:"Mar 21, 2023",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"defaultSidebar",previous:{title:"SDK Contribution Guide",permalink:"/FeatureProbe/reference/sdk-contributor"},next:{title:"Setup database",permalink:"/FeatureProbe/reference/database-setup"}},u={},s=[{value:"Overview",id:"overview",level:2},{value:"Rule calculation",id:"rule-calculation",level:2},{value:"Pre-check",id:"pre-check",level:3},{value:"Rule-check",id:"rule-check",level:3},{value:"Conditional operators",id:"conditional-operators",level:3},{value:"Rollout",id:"rollout",level:3}],p={toc:s};function d(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"rule-evaluation"},"Rule Evaluation"),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"This document introduces the algorithm used for feature flag rule calculation."),(0,r.kt)("h2",{id:"rule-calculation"},"Rule calculation"),(0,r.kt)("p",null,"All server-side SDKs need to provide implementation of feature flag rule calculation."),(0,r.kt)("p",null,"The interface design for SDK's rule calculation is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"private <T> T genericEvaluate(String toggleKey, FPUser user, T defaultValue)\n")),(0,r.kt)("p",null,"Rule calculation consists of the following steps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#pre-check"},"Pre-check"),"\uff1a"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#rule-check"},"Rule-check"),"\uff1a")),(0,r.kt)("h3",{id:"pre-check"},"Pre-check"),(0,r.kt)("p",null,"1\u3001If the current feature flag key does not exist, return the default value set in the function."),(0,r.kt)("p",null,"2\u3001If the feature flag is in an disabled state, return the preset disabled group value in the feature flag configuration."),(0,r.kt)("h3",{id:"rule-check"},"Rule-check"),(0,r.kt)("p",null,"1\u3001In FeatureProbe feature flag rules, matching rules are matched to any user through multiple conditional clauses. To match the rule, all conditional clauses must be satisfied."),(0,r.kt)("p",null,"2\u3001The SDK will iterate through the rules until it finds the first rule that matches the given user. If the rule is configured with a group index, it directly returns the corresponding group value, rule index, feature flag version, and hit reason. If the rule is configured to be rolled out by percentage, the hit group is calculated according to the ",(0,r.kt)("a",{parentName:"p",href:"#rollout"},"rollout logic"),", and the corresponding group value, rule index, feature flag version, and hit reason are returned."),(0,r.kt)("p",null,"3\u3001If none of the rules are hit, match the default rule."),(0,r.kt)("h3",{id:"conditional-operators"},"Conditional operators"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Operators")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Parameter types")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Matching conditions")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"is one of"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The user attribute value exactly matches the clause value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ends with"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The user attribute value ends with the clause value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"starts with"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The user attribute value starts with the clause value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"contains"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The user attribute value contains the clause value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"matches regex"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The user attribute value matches at least one regular expression")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"is not any of"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The user attribute value not matches the clause value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"does not end with"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The user attribute value not ends with the clause value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"does not start with"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The user attribute value not starts with the clause value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"does not contain"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The user attribute value not contains the clause value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"does not match regex"),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},"The user attribute value not matches at least one regular expression")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"is in"),(0,r.kt)("td",{parentName:"tr",align:null},"segment"),(0,r.kt)("td",{parentName:"tr",align:null},"The user is at least in one of your segment")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"is not in"),(0,r.kt)("td",{parentName:"tr",align:null},"segment"),(0,r.kt)("td",{parentName:"tr",align:null},"The user does not belong to any segment")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"after"),(0,r.kt)("td",{parentName:"tr",align:null},"datetime"),(0,r.kt)("td",{parentName:"tr",align:null},"The user attribute value of the user is after or equal to the given date")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"before"),(0,r.kt)("td",{parentName:"tr",align:null},"datetime"),(0,r.kt)("td",{parentName:"tr",align:null},"The user attribute value of the user is before the given date")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"="),(0,r.kt)("td",{parentName:"tr",align:null},"number/semver"),(0,r.kt)("td",{parentName:"tr",align:null},"least equal to one of")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"!="),(0,r.kt)("td",{parentName:"tr",align:null},"number/semver"),(0,r.kt)("td",{parentName:"tr",align:null},"not equal to all")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},">"),(0,r.kt)("td",{parentName:"tr",align:null},"number/semver"),(0,r.kt)("td",{parentName:"tr",align:null},"least greater than one of")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},">="),(0,r.kt)("td",{parentName:"tr",align:null},"number/semver"),(0,r.kt)("td",{parentName:"tr",align:null},"least greater than or equal to one of")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"<"),(0,r.kt)("td",{parentName:"tr",align:null},"number/semver"),(0,r.kt)("td",{parentName:"tr",align:null},"least less than one of")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"<="),(0,r.kt)("td",{parentName:"tr",align:null},"number/semver"),(0,r.kt)("td",{parentName:"tr",align:null},"least less than or equal to one of")))),(0,r.kt)("p",null,'When the value type of the rule condition is "segment", the value list is the unique key of that segment, and the corresponding segment rule can be obtained through this key. Similar to the feature flag rule matching calculation, as long as the current FPUser hits any rule in the population group, it is considered that the FPUser belongs to that population group. If the key does not exist, it is considered that the FPUser does not belong to that population group.'),(0,r.kt)("h3",{id:"rollout"},"Rollout"),(0,r.kt)("p",null,"feature flag can be configured to push out groups by percentage."),(0,r.kt)("p",null,"The format of percentage rules is as follows\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},"[\n    [\n        [\n            0,\n            3333\n        ]\n    ],\n    [\n        [\n            3333,\n            6666\n        ]\n    ],\n    [\n        [\n            6666,\n            10000\n        ]\n    ]\n]\n")),(0,r.kt)("p",null,"The rules are a 3-dimensional array consisting of integers between 0 and 10000. The index of the first dimension array corresponds to the index of the grouping. The second-dimensional array represents the weight of each group."),(0,r.kt)("p",null,"To perform group matching, we only need to use the hash algorithm through the key property of FPUser to calculate an integer value between 0 and 10000, and then look up the position of the integer value in the second-dimensional array to determine the grouping index that the FPUser hits, that is, corresponding to the index of the first-dimensional array."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Hash algorithm"))),(0,r.kt)("p",null,"1\u3001Concatenate the Key value of FPUser with the salt value of the feature flag. If the salt value of the feature flag is null, use the Key of the feature flag instead."),(0,r.kt)("p",null,"2\u3001The previous concatenated string with SHA1 hash algorithm resulting in a hash string."),(0,r.kt)("p",null,"3\u3001Extract the last 4 characters from the hash string and convert it into a decimal integer."),(0,r.kt)("p",null,"4\u3001Perform a modulo operation on the integer obtained in the previous step, resulting in an integer between 0 and 10000 that will serve as the basis for group matching."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Reference (java):"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'private int hash(String hashKey, String hashSalt, int bucketSize) {\n    String value = hashKey + hashSalt;\n    byte[] hashValue;\n    MessageDigest messageDigest;\n    try {\n        messageDigest = MessageDigest.getInstance("SHA-1");\n        messageDigest.update(value.getBytes(StandardCharsets.UTF_8));\n        hashValue = messageDigest.digest();\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException("couldn\'t clone MessageDigest object", e);\n    }\n    byte[] bytes = Arrays.copyOfRange(hashValue, hashValue.length - 4, hashValue.length);\n    return new BigInteger(1, bytes).mod(BigInteger.valueOf(bucketSize)).intValue();\n}\n')))}d.isMDXComponent=!0}}]);